# Automação de views - Regra de Negócio

**Nome do Estagiário:** Melina Nogueira

**Squad:** Git Force

**Data:** 20/09/2024

---
## **Index**
1. **[Tarefa](#tarefa)**
2. **[O que foi feito](#o-que-foi-feito)**

    2.1. [Dia 17/09](#1709)

    2.2. [Dia 18/09](#1809)

    2.3. [Dia 19/09](#1909)

    2.4. [Dia 20/09](#2009)

3. **[Resultado](#resultado)**
4. **[Dúvidas](#dúvidas)**
---
## **Tarefa** 
**Gerar modelo com GenAi para criação automatizada de views a partir de uma regra de negócio.**

**Task - Gerar tabela**
- Criar um dataset no BigQuery;
- Criar uma tabela e definir seus campos
- Preencher com dados mocados

---

## **O que foi feito**

### **17/09**
- Reunião: definição de tarefa e tirar dúvidas;
- Criação do fluxo de tarefa e alinhamento com a outra squad.

### **18/09**
- Criação e atribuição das tasks e organização da sprint;
- Estudo sobre funcionamento dos modelos de GenAI com o dataset e suas tabelas.

### **19/09**
- Foi criado uma tabela aleatória apenas para treinamento, pois não ainda não tinha sido enviado o esquema que deveremos utilizar;
- Criação do dataset `rules_table` para armazenar as tabelas;
- Criação da tabela `rules_to_views`;
```SQL
CREATE TABLE `tarefa-squad.rules_table.rules_to_views` (
  rule_id STRING NOT NULL,
  business_rule STRING NOT NULL,
  view_sql STRING,
  created_at TIMESTAMP NOT NULL
)
```

- Inserir dados na tabela;
```SQL
INSERT INTO `tarefa-squad.rules_table.rules_to_views` 
(rule_id, business_rule, view_sql, created_at)
VALUES
("rule_001", "Agrupar compras por cliente e calcular o total gasto", 
"CREATE VIEW v_compras_clientes AS SELECT client_id, SUM(price * amount) AS total_spent FROM purchases GROUP BY client_id;", 
CURRENT_TIMESTAMP()),

("rule_002", "Agrupar produtos e calcular a média de preço", 
"CREATE VIEW v_produtos_media_preco AS SELECT product_id, AVG(price) AS preco_medio FROM purchases GROUP BY product_id;", 
CURRENT_TIMESTAMP()),

("rule_003", "Contar o número de compras por localização", 
"CREATE VIEW v_compras_por_localizacao AS SELECT purchase_location, COUNT(*) AS total_compras FROM purchases GROUP BY purchase_location;", 
CURRENT_TIMESTAMP()),

("rule_004", "Mostrar o total de vendas por produto nos últimos 3 meses, agrupado por categoria.", 
"CREATE VIEW vendas_por_produto_3meses AS SELECT p.categoria, p.produto, SUM(v.valor) AS total_vendas FROM produtos p INNER JOIN vendas v ON p.id = v.produto_id WHERE v.data >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) GROUP BY p.categoria, p.produto;", 
CURRENT_TIMESTAMP());
```

- Visualização da tabela.
![Tabela rules_to_view](image\tabela_rules.png)

- Criei o dataset `pfs_unificacao_pefisa`

### **20/09**
- O esquema disponibilizado foi divido ao meio, para que eu e minha dupla possamos trabalhar com a mesma tarefa;
- Primeiro analisei minha parte e fiz um rascunho da tabela, identificando qual tipo seria cada coluna;
``` JSON
"cod_estagio_cartao": "4", int
  "des_estagio_cartao": "ENCAMINHADO", string?
  "dth_estagio_cartao": "2024-08-12 05:00:00.000000 UTC", timestamp
  "flg_embs_loja": "N", string
  "flg_cartao_cancelado": "N", string
  "flg_cartao_provisorio": "N", string
  "flg_conta_cancelada": null, string?
  "dth_ult_atu_so": "2024-08-12 05:00:20.000000 UTC", timestamp
  "num_seq_ult_alteracao": "62", int
  "dth_inclusao_reg": "2024-08-15 04:18:47.000000 UTC", timestamp
  "pt_nomeplastico": "SAMUEL NUNES", string
  "ca_arquivolote": "CPEM120824", string
  "ca_id_imagem": null, string?
  "bc_responsavel": "[IRIS]_1056", string
  "ca_codigocancelamento": null, int?
  "ca_flaggeracartasenha": "0", int
  "pt_id_imagem": null string?
```

- Logo após converti o formato JSON para SQL, pois seria mais fácil de se criar uma tabela já que com o JSON teria que salvar o código num arquivo local e upar no bucket.
``` SQL
  cod_estagio_cartao INT64,
  des_estagio_cartao STRING,
  dth_estagio_cartao TIMESTAMP,
  flg_embs_loja STRING,
  flg_cartao_cancelado STRING,
  flg_cartao_provisorio STRING,
  flg_conta_cancelada STRING,
  dth_ult_atu_so TIMESTAMP,
  num_seq_ult_alteracao INT64,
  dth_inclusao_reg TIMESTAMP,
  pt_nomeplastico STRING,
  ca_arquivolote STRING,
  ca_id_imagem INT64,
  bc_responsavel STRING,
  ca_codigocancelamento INT64,
  ca_flaggeracartasenha STRING,
  pt_id_imagem INT64
```

- Depois disso pedi para o ChatGPT gerar dados para preencher a tabela.
``` SQL
INSERT INTO `tarefa-squad.pfs_unificacao_pefisa.cartao`
(cod_estagio_cartao, des_estagio_cartao, dth_estagio_cartao, flg_embs_loja, flg_cartao_cancelado, flg_cartao_provisorio, flg_conta_cancelada, dth_ult_atu_so, num_seq_ult_alteracao, dth_inclusao_reg, pt_nomeplastico, ca_arquivolote, ca_id_imagem, bc_responsavel, ca_codigocancelamento, ca_flaggeracartasenha, pt_id_imagem)
VALUES 
(3, 'PROCESSANDO', '2024-07-25 10:15:00.000000 UTC', 'N', 'N', 'N', NULL, '2024-07-25 11:00:00.000000 UTC', 43, '2024-07-26 09:30:00.000000 UTC', 'JOÃO SILVA', 'CPEM250724', 1234, '[IRIS]_1075', NULL, '1', NULL),
(2, 'APROVADO', '2024-08-01 08:45:00.000000 UTC', 'S', 'N', 'S', NULL, '2024-08-01 09:00:00.000000 UTC', 29, '2024-08-01 09:30:00.000000 UTC', 'MARIA COSTA', 'CPEM010824', NULL, '[IRIS]_1059', 4567, '0', 9876),
(5, 'CANCELADO', '2024-09-10 12:00:00.000000 UTC', 'N', 'S', 'N', 'S', '2024-09-10 12:30:00.000000 UTC', 75, '2024-09-11 08:00:00.000000 UTC', 'ANA PEREIRA', 'CPEM100924', 321, '[IRIS]_1102', NULL, '1', 6543),
(1, 'EMITIDO', '2024-06-18 09:00:00.000000 UTC', 'S', 'N', 'N', NULL, '2024-06-18 09:15:00.000000 UTC', 11, '2024-06-18 10:00:00.000000 UTC', 'PEDRO SANTOS', 'CPEM180624', NULL, '[IRIS]_1045', NULL, '0', NULL),
(6, 'ENCERRADO', '2024-07-15 14:45:00.000000 UTC', 'N', 'S', 'N', NULL, '2024-07-15 15:00:00.000000 UTC', 91, '2024-07-16 07:30:00.000000 UTC', 'LUCAS MENDES', 'CPEM150724', NULL, '[IRIS]_1110', NULL, '1', NULL)
```
---

## **Resultado**
- Esta parte da tabela foi criada e preenchida corretamente.

## **Dúvidas/Impedimentos**
- Há colunas que não é possível saber qual é seu tipo (por ser nulo), então tive que supor qual seria o tipo da coluna;
- Tive dúvida na coluna `num_cartao` pois por questão de segurança ele não mostra todo o número misturando letra e número, porém não sei se é fixo ou é uma questão de segurança/criptografia. Essa parte não é exatamente referente a squad, porém isso pode comprometer no treinamento ou algo do gênero;
- Algumas colunas poderiam ser tratadas com booleano, por exemplo `flg_embs_loja` e `flg_cartao_provisorio`, que tem como dado "N" ou seja do tipo string, isso possivelmente compromete o tamanho (bytes) da tabela e caso haja necessidade de realizar uma operação lógica com a coluna. Neste momento não compensa criar uma função para converter, mas talvez fosse interessante futuramente.